# Message Oriented Middleware
- 서비스 간의 결합을 미들웨어로 줄일 수 있음

# 카프카
- 퍼블리서(발행자) ==> 서브스크라이버..(구독자) 
- 구독자가 어디까지 읽었나 하는 오프셋을 갖고 있음
## 메시지큐 
- 비동기 (성능)
- 디커블링
- Scalability (확장성, 축소에 용이)
## 카프카 vs 래빗엠큐
- 래빗엠큐는 라우팅 키가 있음. (휘발성 데이터)

# 카프카 설명 - 브로커, 토픽, 파티션
- 카프카는 토픽/파티션(1:N) 이 존재 - 같은 파티션 내의 메시지 시간순서보장됨. (다른 파티션 시간순서보장x)
- -> 카프카 클러스터는 최소 세 개 이상의 브로커(카프구성서버)를 통해 가용하라는 것이 권장사항
- 각 토픽에 리더 파티션이 하나씩 존재 / 나머지는 팔로우 파티션
- -> 브로커가 여러개 있어서 카프카 클러스터를 구성하고, 한 토픽 내에서도 여러 파티션을 구성하여 병렬 처리 가능
- 토픽이 각 브로커에 있을 수 있고 하나에만 있을 수도 있음 (레플리케이션 팩터) -> 브로커 숫자에 맞춰주는게 장애 대응에 유리
## 카프카 파티션
- 외부에서 바라보고 있는 파티션이 리더 파티션 
- -> 팔로우 파티션이 리더 파티션의 메세지들을 리플리케이션함 
## 카프카 컨트롤러
- 브로커 들의 장애를 감지 -> 리더 지위를 넘겨주기도 함.
## 카프카 코디네이터 
- 컨슈머 그룹의 장애를 감지. -> 장애가 발생하지 않은 컨슈머로 대신 작업 가능하도록
## 컨슈머
- 파티션/컨슈머(N:1) 관계
- 파티션이 컨슈머 별로 오프셋을 관리하여 각 컨슈머가 어디까지 읽었는지 파악 가능 

## 에크 (ACK) - 에크 방식에 따라서 프로듀서가 카프카의 메시지를 어떤 방식으로 보낼 것인지 판단
- 0 인 경우 : Producer -> Leader Partition에 전송 후 응답값 받지 않음  (메시지 유실 가능성 존재)
- 1 인 경우 : Producer -> Leader Partition에 전송 후 Leader Partition의 응답 받음
- all 인 경우 : Producer -> Leader Partition에 전송 후 Replication 정상 응답까지 기다림 (유실 가능성 없음)
#### 카프카 특징
- disk i/o
- os의 page cache를 통하여 성능 개선 (메모리를 많이 차지하여 카프카와 서비스는 별도로 구성하는 게 좋음)
- 데이터 전송을 배치 처리 (통신 성능 개선) 
#### 카프카 스트림즈
- 카프카에서 지원하는 외부 API라이브러리 카프카 내부 파이프라인

# 카프카 명령어
- 토픽 컨슘 되었나 확인
- kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic loan_request --from-beginning
